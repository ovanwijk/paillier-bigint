function n(n){return(n=BigInt(n))>=0n?n:-n}function t(n){if(1n===(n=BigInt(n)))return 1;let t=1;do{t++}while((n>>=1n)>1n);return t}function e(n,t){if((n=BigInt(n))<=0n|(t=BigInt(t))<=0n)throw new RangeError("a and b MUST be > 0");let e=0n,r=1n,i=1n,o=0n;for(;0n!==n;){const s=t/n,u=t%n,c=e-i*s,h=r-o*s;t=n,n=u,e=i,r=o,i=c,o=h}return{g:t,x:e,y:r}}function r(t,e){if(t=n(t),e=n(e),0n===t)return e;if(0n===e)return t;let r=0n;for(;!(1n&(t|e));)t>>=1n,e>>=1n,r++;for(;!(1n&t);)t>>=1n;do{for(;!(1n&e);)e>>=1n;if(t>e){const n=t;t=e,e=n}e-=t}while(e);return t<<r}function i(t,e){return t=BigInt(t),e=BigInt(e),0n===t&&0n===e?BigInt(0):n(t*e)/r(t,e)}function o(n,t){const r=e(u(n,t),t);if(1n!==r.g)throw new RangeError(`${n.toString()} does not have inverse modulo ${t.toString()}`);return u(r.x,t)}function s(t,e,r){if(0n===(r=BigInt(r)))throw new RangeError("n must be > 0");if(1n===r)return BigInt(0);if(t=u(t,r),(e=BigInt(e))<0n)return o(s(t,n(e),r),r);let i=1n;for(;e>0;)e%2n===1n&&(i=i*t%r),e/=2n,t=t**2n%r;return i}function u(n,t){return(t=BigInt(t))<=0?NaN:(n=BigInt(n)%t)<0?n+t:n}function c(n,t=16,e=!1){if("number"==typeof n&&(n=BigInt(n)),n<0)throw RangeError("w MUST be >= 0");return new Promise(((e,r)=>{const i=new Worker(p());i.onmessage=n=>{i.terminate(),e(n.data.isPrime)},i.onmessageerror=n=>{r(n)},i.postMessage({rnd:n,iterations:t,id:0})}))}function h(n,t=16){if(n<1)throw new RangeError("bitLength MUST be > 0");if(!m){let e=0n;do{e=d(l(n,!0))}while(!y(e,t));return new Promise((n=>{n(e)}))}return new Promise((e=>{const r=[],i=(i,o)=>{if(i.isPrime){for(let n=0;n<r.length;n++)r[n].terminate();for(;r.length;)r.pop();e(i.value)}else{const e=d(l(n,!0));try{o.postMessage({rnd:e,iterations:t,id:i.id})}catch(n){}}};{const n=p();for(let t=0;t<self.navigator.hardwareConcurrency-1;t++){const t=new Worker(n);t.onmessage=n=>i(n.data,t),r.push(t)}}for(let e=0;e<r.length;e++)g(n,!0).then((function(n){const i=d(n);r[e].postMessage({rnd:i,iterations:t,id:e})}))}))}function a(n,t=16){if(n<1)throw new RangeError("bitLength MUST be > 0");let e=0n;do{e=d(l(n,!0))}while(!y(e,t));return e}function f(n,e=1n){if(n<=0n||e<0n||n<=e)throw new RangeError("Arguments MUST be: max > 0 && min >=0 && max > min");const r=n-e,i=t(r);let o;do{o=d(l(i))}while(o>r);return o+e}function g(n,t=!1){if(n<1)throw new RangeError("bitLength MUST be > 0");const e=Math.ceil(n/8),r=n%8;return new Promise((n=>{(function(n,t=!1){if(n<1)throw new RangeError("byteLength MUST be > 0");return new Promise((function(e,r){{const r=new Uint8Array(n);self.crypto.getRandomValues(r),t&&(r[0]=128|r[0]),e(r)}}))})(e,!1).then((function(e){if(r&&(e[0]=e[0]&2**r-1),t){const n=r?2**(r-1):128;e[0]=e[0]|n}n(e)}))}))}function l(n,t=!1){if(n<1)throw new RangeError("bitLength MUST be > 0");const e=w(Math.ceil(n/8),!1),r=n%8;if(r&&(e[0]=e[0]&2**r-1),t){const n=r?2**(r-1):128;e[0]=e[0]|n}return e}function w(n,t=!1){if(n<1)throw new RangeError("byteLength MUST be > 0");{const e=new Uint8Array(n);return self.crypto.getRandomValues(e),t&&(e[0]=128|e[0]),e}}function d(n){let t=0n;for(const e of n.values()){const n=BigInt(e);t=(t<<BigInt(8))+n}return t}function p(){let n=`'use strict';const ${e.name}=${e.toString()};const ${o.name}=${o.toString()};const ${s.name}=${s.toString()};const ${u.name}=${u.toString()};const ${l.name}=${l.toString()};const ${w.name}=${w.toString()};const ${f.name}=${f.toString()};const ${c.name}=${y.toString()};${t.toString()}${d.toString()}`;return n+=`onmessage = ${async function(n){const t=await c(n.data.rnd,n.data.iterations);postMessage({isPrime:t,value:n.data.rnd,id:n.data.id})}.toString()};`,function(n){n=`(() => {${n}})()`;const t=new Blob([n],{type:"text/javascript"});return window.URL.createObjectURL(t)}(n)}function y(n,t=16){if(2n===n)return!0;if(0n===(1n&n)||1n===n)return!1;const e=[3n,5n,7n,11n,13n,17n,19n,23n,29n,31n,37n,41n,43n,47n,53n,59n,61n,67n,71n,73n,79n,83n,89n,97n,101n,103n,107n,109n,113n,127n,131n,137n,139n,149n,151n,157n,163n,167n,173n,179n,181n,191n,193n,197n,199n,211n,223n,227n,229n,233n,239n,241n,251n,257n,263n,269n,271n,277n,281n,283n,293n,307n,311n,313n,317n,331n,337n,347n,349n,353n,359n,367n,373n,379n,383n,389n,397n,401n,409n,419n,421n,431n,433n,439n,443n,449n,457n,461n,463n,467n,479n,487n,491n,499n,503n,509n,521n,523n,541n,547n,557n,563n,569n,571n,577n,587n,593n,599n,601n,607n,613n,617n,619n,631n,641n,643n,647n,653n,659n,661n,673n,677n,683n,691n,701n,709n,719n,727n,733n,739n,743n,751n,757n,761n,769n,773n,787n,797n,809n,811n,821n,823n,827n,829n,839n,853n,857n,859n,863n,877n,881n,883n,887n,907n,911n,919n,929n,937n,941n,947n,953n,967n,971n,977n,983n,991n,997n,1009n,1013n,1019n,1021n,1031n,1033n,1039n,1049n,1051n,1061n,1063n,1069n,1087n,1091n,1093n,1097n,1103n,1109n,1117n,1123n,1129n,1151n,1153n,1163n,1171n,1181n,1187n,1193n,1201n,1213n,1217n,1223n,1229n,1231n,1237n,1249n,1259n,1277n,1279n,1283n,1289n,1291n,1297n,1301n,1303n,1307n,1319n,1321n,1327n,1361n,1367n,1373n,1381n,1399n,1409n,1423n,1427n,1429n,1433n,1439n,1447n,1451n,1453n,1459n,1471n,1481n,1483n,1487n,1489n,1493n,1499n,1511n,1523n,1531n,1543n,1549n,1553n,1559n,1567n,1571n,1579n,1583n,1597n];for(let t=0;t<e.length&&e[t]<=n;t++){const r=e[t];if(n===r)return!0;if(n%r===0n)return!1}let r=0n;const i=n-1n;let o=i;for(;o%2n===0n;)o/=2n,++r;const u=i/2n**r;do{let t=s(f(i,2n),u,n);if(1n===t||t===i)continue;let e=1;for(;e<r&&(t=s(t,2n,n),t!==i);){if(1n===t)return!1;e++}if(t!==i)return!1}while(--t);return!0}let m=!1;self.Worker&&(m=!0);class b{constructor(n,t){this.n=n,this._n2=this.n**2n,this.g=t}get bitLength(){return t(this.n)}encrypt(n,t=null){if(null===t)do{t=f(this.n)}while(1n!==r(t,this.n));return s(this.g,n,this._n2)*s(t,this.n,this._n2)%this._n2}encryptOtherNA(n,t,e){return s(this.g,n,this._n2)*s(t,this.n,this._n2)%e}encryptOtherNB(n,t,e){return s(this.g,n,e)*s(t,this.n,this._n2)%this._n2}encryptOtherNC(n,t,e){return s(this.g,n,this._n2)*s(t,this.n,e)%this._n2}encryptOtherNF(n,t,e){return s(this.g,n,this._n2)*s(t,this.n,e)%e}encryptOtherND(n,t,e){return s(this.g,n,e)*s(t,this.n,e)%this._n2}encryptOtherNE(n,t,e){return s(this.g,n,e)*s(t,this.n,e)%this._n2}addition(...n){return n.reduce(((n,t)=>n*t%this._n2),1n)}multiply(n,t){return s(BigInt(n),BigInt(t),this._n2)}}class S{constructor(n,t,e,r=null,i=null){this.lambda=n,this.mu=t,this._p=r||null,this._q=i||null,this.publicKey=e}get bitLength(){return t(this.publicKey.n)}get n(){return this.publicKey.n}decrypt(n){return $(s(n,this.lambda,this.publicKey._n2),this.publicKey.n)*this.mu%this.publicKey.n}getRandomFactor(n){if(this.publicKey.g!==this.n+1n)throw RangeError("Cannot recover the random factor if publicKey.g != publicKey.n + 1. You should generate yout keys using the simple variant, e.g. generateRandomKeys(3072, true) )");const t=this.decrypt(n),e=(this._p-1n)*(this._q-1n),r=o(this.n,e);return s(n*(1n-t*this.n)%this.publicKey._n2,r,this.n)}}function $(n,t){return(n-1n)/t}function B(n,t,e){return s(BigInt(n),BigInt(t),e)}function _(n,t){var e=0;do{e=f(n)}while(1n!==r(e,n)&&1n!==r(e,t));return e}async function I(n=3072,e=!1){let r,u,c,a,f,g;do{r=await h(Math.floor(n/2)+1),u=await h(Math.floor(n/2)),c=r*u}while(u===r||t(c)!==n);if(!0===e)a=c+1n,f=(r-1n)*(u-1n),g=o(f,c);else{const n=c**2n;a=K(c,n),f=i(r-1n,u-1n),g=o($(s(a,f,n),c),c)}const l=new b(c,a);return{publicKey:l,privateKey:new S(f,g,l,r,u)}}function M(n=3072,e=!1){let r,u,c,h,f,g;do{r=a(Math.floor(n/2)+1),u=a(Math.floor(n/2)),c=r*u}while(u===r||t(c)!==n);if(!0===e)h=c+1n,f=(r-1n)*(u-1n),g=o(f,c);else{const n=c**2n;h=K(c,n),f=i(r-1n,u-1n),g=o($(s(h,f,n),c),c)}const l=new b(c,h);return{publicKey:l,privateKey:new S(f,g,l,r,u)}}function R(n,t,e){let r,u,c;r=n*t;const h=r**2n;e=e||K(r,h),u=i(n-1n,t-1n),c=o($(s(e,u,h),r),r);const a=new b(r,e);return{publicKey:a,privateKey:new S(u,c,a,n,t)}}function K(n,t){return(f(n)*n+1n)*s(f(n),n,t)%t}export{S as PrivateKey,b as PublicKey,_ as generateDualG,I as generateRandomKeys,M as generateRandomKeysSync,R as keysFromPrimes,B as multiplyOtherN2};
